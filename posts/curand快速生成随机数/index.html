<!DOCTYPE html>
<html lang="en">
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>cuRAND快速生成大量随机数 | Cayman</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1671.5">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1"><meta name="generator" content="Hugo 0.55.6" />    <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style><span class="Apple-converted-space"> </span></span></p>
</body>
</html>

<body>
  <section class="page-header">
  <h1 class="project-name">
    Cayman Hugo Theme
  </h1>
  <h2 class="project-tagline">
    A clean, responsive Hugo theme, ported from the original Jekyll Cayman theme
  </h2>
  <nav>
    
    
      
      
      
      
      <a href="/" class="btn">Blog</a>
    
      
      
      
      
      <a href="/tags/" class="btn">Tags</a>
    
      
      
      
      
      <a href="/about/" class="btn">About</a>
    
      
      
      
      
      <a href="/index.xml" class="btn">RSS</a>
    
  </nav>
</section>

  <section class="main-content">
    
  <h1>cuRAND快速生成大量随机数</h1>
  <p>在一些算法中，快速生成大量伪随机数显得尤为重要。cuRAND 提供了在 host 端调用 device 端一次生成大量随机数储存在 device 端的 global 内存中和在 device 端调用一次产生单个随机数共 device 代码即时使用两种 API 。而后者使用不当可能会造成几个数量级的性能差距和效果差距，本文将主要对此进行分析。</p>

<p>在下面的代码中，我使用了不同的参数方式来生成了一些随机数，然后使用 <a href="https://zkyue.github.io/posts/使用nvprof来检测cuda程序运行效率/">nvprof</a> 来对它们的性能做了比较, 并且把随机结果用OpenCV 可视化出来。</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#bc7a00">#include</span> <span style="color:#bc7a00">&lt;curand_kernel.h&gt;</span><span style="color:#bc7a00">
</span><span style="color:#bc7a00">#include</span> <span style="color:#bc7a00">&lt;opencv2/opencv.hpp&gt;</span><span style="color:#bc7a00">
</span><span style="color:#bc7a00"></span>
<span style="color:#bc7a00">#define COLS 400
</span><span style="color:#bc7a00">#define ROWS 300
</span><span style="color:#bc7a00">#define N (COLS*ROWS)
</span><span style="color:#bc7a00"></span>
__global__ <span style="color:#b00040">void</span> <span style="color:#00f">random_test</span>(curandState <span style="color:#666">*</span>states, <span style="color:#b00040">float</span> <span style="color:#666">*</span>data_f)
{
    <span style="color:#b00040">int</span> x <span style="color:#666">=</span> blockIdx.x <span style="color:#666">*</span> blockDim.x <span style="color:#666">+</span> threadIdx.x;
    <span style="color:#b00040">int</span> y <span style="color:#666">=</span> blockIdx.y <span style="color:#666">*</span> blockDim.y <span style="color:#666">+</span> threadIdx.y;
	  <span style="color:#008000;font-weight:bold">if</span>(x <span style="color:#666">&gt;=</span> COLS) <span style="color:#008000;font-weight:bold">return</span>;
	  <span style="color:#008000;font-weight:bold">if</span>(y <span style="color:#666">&gt;=</span> ROWS)<span style="color:#008000;font-weight:bold">return</span>;
    <span style="color:#008000;font-weight:bold">const</span> <span style="color:#b00040">int</span> tid <span style="color:#666">=</span> y <span style="color:#666">*</span> COLS <span style="color:#666">+</span> x;
    curandState state <span style="color:#666">=</span> states[tid];
    
    <span style="color:#408080;font-style:italic">//curand_init(clock64(), 0, 0, &amp;state);
</span><span style="color:#408080;font-style:italic"></span>    <span style="color:#408080;font-style:italic">//curand_init(clock64(), pt.y, 0, &amp;state);
</span><span style="color:#408080;font-style:italic"></span>    <span style="color:#408080;font-style:italic">//curand_init(clock64(), 0, pt.x, &amp;state);
</span><span style="color:#408080;font-style:italic"></span>    <span style="color:#408080;font-style:italic">//curand_init(clock64(), pt.y, pt.x, &amp;state);
</span><span style="color:#408080;font-style:italic"></span>    curand_init(tid, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">&amp;</span>state);
    <span style="color:#408080;font-style:italic">//curand_init(tid, pt.y, 0, &amp;state);
</span><span style="color:#408080;font-style:italic"></span>    <span style="color:#408080;font-style:italic">//curand_init(tid, 0, pt.x, &amp;state);
</span><span style="color:#408080;font-style:italic"></span>    <span style="color:#408080;font-style:italic">//curand_init(tid, pt.y, pt.x, &amp;state);
</span><span style="color:#408080;font-style:italic"></span>    data_f[tid] <span style="color:#666">=</span> curand_uniform(<span style="color:#666">&amp;</span>state)<span style="color:#666">*</span><span style="color:#666">255</span>;
    states[tid]<span style="color:#666">=</span>state;
}

<span style="color:#b00040">int</span> <span style="color:#00f">main</span>()
{

    cudaFree(<span style="color:#666">0</span>); 

    curandState <span style="color:#666">*</span>states;
    <span style="color:#b00040">float</span> <span style="color:#666">*</span>data;
    cudaMalloc((<span style="color:#b00040">void</span> <span style="color:#666">**</span>)<span style="color:#666">&amp;</span>states, N<span style="color:#666">*</span> <span style="color:#008000;font-weight:bold">sizeof</span>(curandState));
    cudaMalloc((<span style="color:#b00040">void</span> <span style="color:#666">**</span>)<span style="color:#666">&amp;</span>data, N<span style="color:#666">*</span> <span style="color:#008000;font-weight:bold">sizeof</span>(<span style="color:#b00040">float</span>));

    <span style="color:#008000;font-weight:bold">const</span> <span style="color:#b00040">int</span> BLOCK_W <span style="color:#666">=</span> <span style="color:#666">32</span>;
	  <span style="color:#008000;font-weight:bold">const</span> <span style="color:#b00040">int</span> BLOCK_H  <span style="color:#666">=</span> (BLOCK_W <span style="color:#666">/</span> <span style="color:#666">2</span>);
    dim3 block(BLOCK_W, BLOCK_H, <span style="color:#666">1</span>);
	  dim3 grid((COLS <span style="color:#666">+</span> block.x <span style="color:#666">-</span> <span style="color:#666">1</span>) <span style="color:#666">/</span> block.x, (ROWS <span style="color:#666">+</span> block.y <span style="color:#666">-</span> <span style="color:#666">1</span>) <span style="color:#666">/</span> block.y, <span style="color:#666">1</span>);
    random_test<span style="color:#666">&lt;&lt;&lt;</span>grid,block<span style="color:#666">&gt;&gt;&gt;</span>(states, data);

    cv<span style="color:#666">::</span>Mat mat(ROWS, COLS, CV_32FC1);
    cudaMemcpy(mat.data, data, N<span style="color:#666">*</span><span style="color:#008000;font-weight:bold">sizeof</span>(<span style="color:#b00040">float</span>),cudaMemcpyDeviceToHost);
    mat.convertTo(mat, CV_8U);
    cv<span style="color:#666">::</span>imwrite(<span style="color:#ba2121">&#34;mat.png&#34;</span>,mat);
    
    cudaFree(states);
    cudaFree(data);

    cudaDeviceReset();
    <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">0</span>;
}
</code></pre></div>
<p><img src="https://github.com/zkyue/Picturefloor/raw/master/random_test.jpeg" alt="random_test" /></p>

<p>上图中每个标题的前三节是 <code>curand_init()</code> 的输入参数，最后一节为运行时间。不同的参数对运行时间的影响是几个数量级的，而且随着数据的增大呈非线性增长。</p>

<p>现在来分析一下这其中的原因：</p>

<pre><code>void curand_init( unsigned long long seed, unsigned long long sequence, unsigned long long offset, curandState_t* state )
</code></pre>

<p>这几个参数的意思是将<code>state</code>初始化到经过 $2^{67}*sequence+offset$ 次调用以 seed 为种子的 <code>curand()</code>函数以后的状态 , sequence 和 offset 的值决定了<code>curand_init()</code> 的运算量。</p>

<p><code>curand_init()</code>在 kernel 里使用需要遵循以下几点：</p>

<ul>
<li><code>curand_init()</code> 会使用较多的寄存器资源和 local memery，最好放在单独的 kernel 中运行以避免系统资源不足产生 global memery IO。</li>
<li><code>curand_init()</code> 可能会很慢，在使用时可以把经过<code>curand_init()</code> 的 curandState 存放在 global memory 中，用时取回本地，用完放回原位，方便下次使用，上文的代码就对 curandState 进行了回存。</li>
<li>在单线程程序中，经常会使用系统时间作为随机数发生器的种子，然而在GPU中由于大量线程的并发，仍然使用时间做种子如<code>random_bad()</code> 会使得很多线程的种子是一样的，在结果图片的前两幅所示，每个线程block中产生的随机数为常数。</li>
<li>为了最大化速度，可以为每个线程使用不同的随机数种子，然后以 0 作为 subsequence 和 offset,, 但这样生成的随机数不同线程之间会有一定的相关性，如果你的应用要求不苛刻的话这个无疑是最好的选择。</li>
</ul>


    <footer class="site-footer">
  <span class="site-footer-credits">
    Made with <a href="https://gohugo.io/">Hugo</a>. Themed by <a href="https://github.com/zwbetz-gh/cayman-hugo-theme">Cayman</a>. Deployed to <a href="https://www.netlify.com/">Netlify</a>.
  </span>
</footer>

  </section>
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-123456789-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

</body>
</html>
