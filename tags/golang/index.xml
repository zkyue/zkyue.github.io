<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on 大香蕉</title>
    <link>https://zkyue.github.io/tags/golang/</link>
    <description>Recent content in golang on 大香蕉</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://zkyue.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PatchMatch Stereo</title>
      <link>https://zkyue.github.io/cayman-typography/</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zkyue.github.io/cayman-typography/</guid>
      <description>这篇论文是我进入立体匹配领域后读的第一篇论文，读的十分痛苦，最后总算把问题解决了，写篇博客谈谈我的理解。
PatchMatch Stereo 的主要创新点在于：
 为了解决 fronto-parallel bias， 引入了 slanted support window 为了寻找 slanted support window， 使用了 PatchMatch 算法  什么是 fronto-parallel bias ？在传统的局部窗口立体匹配过程中，参考图像的局部窗口在目标图像中每次位移一个像素同时计算 cost， 取 cost 最小的点为匹配点。然而这种计算只有当被摄物体的表面是和成像平面平行的时候才是成立的。如下图所示：当物体AB与像平面平行，它在左右相机中成像是一样大的，这时候用局部窗口在左右图像中去找匹配是可行的，然后当物体AB是斜着的时候，再用一个局部窗口去匹配 cost 最小的点就不一定准确了。
回到 PatchMatch Stereo 这篇文章，在 x、y、d(视差）的三维空间中，作者去对每一个像素点拟合一个平面，来解决 fronto-parallel bias 问题。下图是作者画的二维示图，(a) 代表传统方法，由于视差每次只能移动一个像素，且局部像素点都在一个平面内，(a) 中只有 $P$ 点能够完美拟合，(b) 代表作者方法，视差是浮点数，可以解决出 $S$ 点以外的情况，按照作者的说法，$S$ 点也可以得到很好的近似。需要注意的是，如果每个图像点有自己的视差拟合平面，按理说 $S$ 点也应该能够完美拟合才对，但是下面的一个红色线段代表的单个像素的匹配窗口的大小，窗口中的每一个像素去计算代价是用的都是和中心点一样的平面参数，所以这个窗口不能弯曲，因为窗口内的其他点和中心点此时用的同一个平面法向量。理论上讲计算 cost 每个点用不同的平面参数能 handle 包括 $$S$$ 的所有情况，但这样会导致 PatchMatch 不收敛。
接下来的问题就是在 3D 视差空间中去寻找这样子的一个平面了，它能够使得每一个点的 cost 尽可能的小，一个平面可以由法向量和一个点决定，这里面每一个点有$$\rm N = (n_1, n_2, n_3)^{\rm T}$$ 和 $d$ 四个自由度，在全局空间中搜索最优解十分困难，而 PatchMatch 可以快速的得到一个近似解。</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://zkyue.github.io/hugo-template-primer/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zkyue.github.io/hugo-template-primer/</guid>
      <description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description>
    </item>
    
  </channel>
</rss>